use crate::global_parameters::DEFAUT_DOMAINS;
use crate::parameters;
use crate::parameters::{
    AtomicPatternParameters, BrDecompositionParameters, CmuxParameters, GlweParameters,
    KeyswitchParameters, PbsParameters,
};
use crate::security;
use concrete_commons::dispersion::{DispersionParameter, Variance};
use concrete_commons::key_kinds::BinaryKeyKind;
use concrete_commons::numeric::UnsignedInteger;
use concrete_commons::parameters::{
    DecompositionBaseLog, DecompositionLevelCount, GlweDimension, LweDimension, PolynomialSize,
};

const FFT_SCALING_WEIGHT: &[f64; DEFAUT_DOMAINS.glwe_pbs_constrained.glwe_dimension.end as usize] =
    &[
        f64::NAN,
        -6.1,
        -4.,
        -4.,
        -2.736_268_71,
        -2.910_704_72,
        -2.592_853_92,
    ];
const FFT_POLY_WEIGHT: &[f64; DEFAUT_DOMAINS.glwe_pbs_constrained.glwe_dimension.end as usize] = &[
    f64::NAN,
    2.1815,
    2.1,
    2.16,
    2.061_964_27,
    2.113_887_34,
    2.112_397_6,
];

/// Additional noise generated by the keyswitch step.
pub fn variance_keyswitch(
    param: KeyswitchParameters,
    ciphertext_modulus_log: u32,
    variance_ksk: Variance,
) -> Variance {
    concrete_npe::estimate_keyswitch_noise_lwe_to_glwe_with_constant_terms::<
        Variance,
        Variance,
        BinaryKeyKind,
    >(
        LweDimension(param.input_lwe_dimension.0 as usize),
        Variance(0.0),
        variance_ksk,
        DecompositionBaseLog(param.ks_decomposition_parameter.log2_base as usize),
        DecompositionLevelCount(param.ks_decomposition_parameter.level as usize),
        ciphertext_modulus_log,
    )
}

/// Compute the variance parameter of the keyswitch key.
pub fn variance_ksk(
    internal_ks_output_lwe_dimension: u64,
    ciphertext_modulus_log: u32,
    security_level: u64,
) -> Variance {
    let glwe_params = GlweParameters {
        log2_polynomial_size: 0,
        glwe_dimension: internal_ks_output_lwe_dimension,
    };
    // https://github.com/zama-ai/concrete-optimizer/blob/prototype/python/optimizer/noise_formulas/keyswitch.py#L13
    security::glwe::minimal_variance(glwe_params, ciphertext_modulus_log, security_level)
}

/// Additional noise generated by fft computation
pub fn fft_noise(
    internal_ks_output_lwe_dimension: u64, //n_small
    glwe_params: GlweParameters,
    br_decomposition_parameter: BrDecompositionParameters,
    ciphertext_modulus_log: u32,
) -> Variance {
    // https://github.com/zama-ai/concrete-optimizer/blob/prototype/python/optimizer/noise_formulas/bootstrap.py#L25
    let n = internal_ks_output_lwe_dimension as f64;
    let b = 2_f64.powi(br_decomposition_parameter.log2_base as i32);
    let l = br_decomposition_parameter.level as f64;
    let big_n = glwe_params.polynomial_size() as f64;
    let k = glwe_params.glwe_dimension;
    assert!(k > 0, "k = {}", k);
    assert!(
        DEFAUT_DOMAINS.glwe_pbs_constrained.glwe_dimension.end > k,
        "k={} and bound={}",
        k,
        DEFAUT_DOMAINS.glwe_pbs_constrained.glwe_dimension.end
    );
    // 22 = 2 x 11, 11 = 64 -53
    let scale_margin = (1_u64 << 22) as f64;
    let scaling_weight = FFT_SCALING_WEIGHT[k as usize];
    let poly_weight = FFT_POLY_WEIGHT[k as usize];
    let res = n
        * f64::exp2(scaling_weight)
        * scale_margin
        * l
        * b
        * b
        * big_n.powf(poly_weight)
        * (k as f64 + 1.);
    Variance::from_modular_variance(res, ciphertext_modulus_log)
}

/// Final reduced noise generated by the final bootstrap step.
/// Note that it does not depends from input noise, assuming the bootstrap is successful
pub fn variance_bootstrap(
    param: PbsParameters,
    ciphertext_modulus_log: u32,
    variance_bsk: Variance,
) -> Variance {
    let out_variance_pbs = concrete_npe::estimate_pbs_noise::<Variance, BinaryKeyKind>(
        LweDimension(param.internal_lwe_dimension.0 as usize),
        PolynomialSize(param.output_glwe_params.polynomial_size() as usize),
        GlweDimension(param.output_glwe_params.glwe_dimension as usize),
        DecompositionBaseLog(param.br_decomposition_parameter.log2_base as usize),
        DecompositionLevelCount(param.br_decomposition_parameter.level as usize),
        variance_bsk,
        ciphertext_modulus_log,
    );

    let additional_fft_noise = fft_noise(
        param.internal_lwe_dimension.0,
        param.output_glwe_params,
        param.br_decomposition_parameter,
        ciphertext_modulus_log,
    );
    Variance(out_variance_pbs.get_variance() + additional_fft_noise.get_variance())
}

pub fn variance_cmux(
    cmux_params: CmuxParameters,
    ciphertext_modulus_log: u32,
    variance_bsk: Variance,
) -> Variance {
    let pbs_params = PbsParameters {
        internal_lwe_dimension: parameters::LweDimension(1),
        br_decomposition_parameter: cmux_params.br_decomposition_parameter,
        output_glwe_params: cmux_params.output_glwe_params,
    };
    variance_bootstrap(pbs_params, ciphertext_modulus_log, variance_bsk)
}

pub fn estimate_modulus_switching_noise_with_binary_key(
    internal_ks_output_lwe_dimension: u64,
    glwe_polynomial_size: u64,
    ciphertext_modulus_log: u32,
) -> Variance {
    #[allow(clippy::cast_sign_loss)]
    let nb_msb = (f64::log2(glwe_polynomial_size as f64) as usize) + 1;
    concrete_npe::estimate_modulus_switching_noise_with_binary_key::<Variance>(
        LweDimension(internal_ks_output_lwe_dimension as usize),
        nb_msb,
        Variance(0.0),
        ciphertext_modulus_log,
    )
}

pub fn maximal_noise<D>(
    input_variance: Variance,
    param: AtomicPatternParameters,
    ciphertext_modulus_log: u32, //log(q)
    security_level: u64,
) -> Variance
where
    D: DispersionParameter,
{
    let v_keyswitch = variance_keyswitch(
        param.ks_parameters(),
        ciphertext_modulus_log,
        variance_ksk(
            param.internal_lwe_dimension.0,
            ciphertext_modulus_log,
            security_level,
        ),
    );
    let v_modulus_switch = estimate_modulus_switching_noise_with_binary_key(
        param.internal_lwe_dimension.0,
        param.output_glwe_params.polynomial_size(),
        ciphertext_modulus_log,
    );
    Variance(
        input_variance.get_variance()
            + v_keyswitch.get_variance()
            + v_modulus_switch.get_variance(),
    )
}

/// The maximal noise is attained at the end of the modulus switch.
pub fn maximal_noise_multi_sum<D, W, Ignored>(
    dispersions: &[D],
    weights_tuples: &[(W, Ignored)],
    param: AtomicPatternParameters,
    ciphertext_modulus_log: u32,
    security_level: u64,
) -> Variance
where
    D: DispersionParameter,
    W: UnsignedInteger,
{
    let v_out_multi_sum = if dispersions.is_empty() {
        let mut weights = vec![];
        for (weight, _) in weights_tuples.iter() {
            weights.push(*weight);
        }
        concrete_npe::estimate_weighted_sum_noise(dispersions, weights.as_slice())
    } else {
        Variance(0.0)
    };
    maximal_noise::<D>(
        v_out_multi_sum,
        param,
        ciphertext_modulus_log,
        security_level,
    )
}

/// The output noise is the variance boostrap.
pub fn output_noise<D, W>(
    param: AtomicPatternParameters,
    ciphertext_modulus_log: u32,
    security_level: u64,
) -> Variance
where
    D: DispersionParameter,
    W: UnsignedInteger,
{
    // https://github.com/zama-ai/concrete-optimizer/blob/prototype/python/optimizer/noise_formulas/bootstrap.py#L66
    let variance_bsk = security::glwe::minimal_variance(
        param.output_glwe_params,
        ciphertext_modulus_log,
        security_level,
    );
    variance_bootstrap(param.pbs_parameters(), ciphertext_modulus_log, variance_bsk)
}

#[cfg(test)]
mod tests {
    use crate::parameters::{
        BrDecompositionParameters, GlweParameters, KsDecompositionParameters, LweDimension,
    };

    use super::*;

    #[test]
    fn golden_python_prototype_security_variance_keyswitch_1() {
        let golden_modular_variance = 5.997_880_135_602_194e68;
        let internal_ks_output_lwe_dimension = 1024;
        let ciphertext_modulus_log = 128;
        let security = 128;

        let param = KeyswitchParameters {
            input_lwe_dimension: LweDimension(4096),
            output_lwe_dimension: LweDimension(internal_ks_output_lwe_dimension),
            ks_decomposition_parameter: KsDecompositionParameters {
                level: 9,
                log2_base: 5,
            },
        };

        let actual = variance_keyswitch(
            param,
            ciphertext_modulus_log,
            variance_ksk(
                internal_ks_output_lwe_dimension,
                ciphertext_modulus_log,
                security,
            ),
        )
        .get_modular_variance(128);
        approx::assert_relative_eq!(actual, golden_modular_variance, max_relative = 1e-8);
    }

    #[test]
    fn golden_python_prototype_security_variance_keyswitch_2() {
        // let golden_modular_variance = 8.580795457940938e+66;
        // the full npe implements a part of the full estimation
        let golden_modular_variance = 7.407_691_550_271_225e48; // full estimation
        let internal_ks_output_lwe_dimension = 512;
        let ciphertext_modulus_log = 64;
        let security = 128;

        let param = KeyswitchParameters {
            input_lwe_dimension: LweDimension(2048),
            output_lwe_dimension: LweDimension(internal_ks_output_lwe_dimension),
            ks_decomposition_parameter: KsDecompositionParameters {
                level: 2,
                log2_base: 24,
            },
        };

        let actual = variance_keyswitch(
            param,
            ciphertext_modulus_log,
            variance_ksk(
                internal_ks_output_lwe_dimension,
                ciphertext_modulus_log,
                security,
            ),
        )
        .get_modular_variance(64);
        approx::assert_relative_eq!(actual, golden_modular_variance, max_relative = 1e-8);
    }

    #[test]
    fn security_variance_bootstrap_1() {
        let ref_modular_variance = 3.494_755_583_952_549e31;
        let glwe_params = GlweParameters {
            log2_polynomial_size: 12,
            glwe_dimension: 2,
        };
        let ciphertext_modulus_log = 64;
        let security = 128;
        let variance_bsk =
            security::glwe::minimal_variance(glwe_params, ciphertext_modulus_log, security);

        let param = PbsParameters {
            internal_lwe_dimension: LweDimension(2048),
            br_decomposition_parameter: BrDecompositionParameters {
                level: 2,
                log2_base: 24,
            },
            output_glwe_params: glwe_params,
        };

        let actual = variance_bootstrap(param, ciphertext_modulus_log, variance_bsk)
            .get_modular_variance(64);
        approx::assert_relative_eq!(actual, ref_modular_variance, max_relative = 1e-8);
    }

    #[test]
    fn golden_python_prototype_security_variance_bootstrap_2() {
        // golden value include fft correction
        let golden_modular_variance = 3.269_722_907_894_341e55;
        let glwe_params = GlweParameters {
            log2_polynomial_size: 12,
            glwe_dimension: 4,
        };
        let ciphertext_modulus_log = 128;
        let security = 128;
        let variance_bsk =
            security::glwe::minimal_variance(glwe_params, ciphertext_modulus_log, security);

        let param = PbsParameters {
            internal_lwe_dimension: LweDimension(1024),
            br_decomposition_parameter: BrDecompositionParameters {
                level: 9,
                log2_base: 5,
            },
            output_glwe_params: glwe_params,
        };

        let actual = variance_bootstrap(param, ciphertext_modulus_log, variance_bsk)
            .get_modular_variance(128);
        approx::assert_relative_eq!(actual, golden_modular_variance, max_relative = 1e-8);
    }
}
