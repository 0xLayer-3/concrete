//! Compiler module

use crate::mlir::ffi::*;

#[derive(Debug)]
pub struct CompilationError(String);

#[derive(Debug)]
pub struct ServerLambdaLoadError(String);

/// Parse the MLIR code and returns it.
///
/// The function parse the provided MLIR textual representation and returns it. It would fail with
/// an error message to stderr reporting what's bad with the parsed IR.
///
/// # Examples
/// ```
/// use concrete_compiler_rust::compiler::*;
///
/// let module_to_compile = "
///     func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
///         %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
///         return %0 : !FHE.eint<5>
///     }";
/// let result_str = round_trip(module_to_compile);
/// ```
///
pub fn round_trip(mlir_code: &str) -> Result<String, CompilationError> {
    unsafe {
        let engine = compilerEngineCreate();
        let mlir_code_buffer = mlir_code.as_bytes();
        let compilation_result = compilerEngineCompile(
            engine,
            MlirStringRef {
                data: mlir_code_buffer.as_ptr() as *const std::os::raw::c_char,
                length: mlir_code_buffer.len() as size_t,
            },
            CompilationTarget_ROUND_TRIP,
        );
        if compilationResultIsNull(compilation_result) {
            return Err(CompilationError("roundtrip error".to_string()));
        }
        let module_compiled = compilationResultGetModuleString(compilation_result);
        let result_str = String::from_utf8_lossy(std::slice::from_raw_parts(
            module_compiled.data as *const u8,
            module_compiled.length as usize,
        ))
        .to_string();
        compilationResultDestroyModuleString(module_compiled);
        compilerEngineDestroy(engine);
        Ok(result_str)
    }
}

/// Support for compiling and executing libraries.
pub struct LibrarySupport {
    support: crate::mlir::ffi::LibrarySupport,
}

impl LibrarySupport {
    /// LibrarySupport manages build files generated by the compiler under the `output_dir_path`.
    ///
    /// The compiled library needs to link to the runtime for proper execution.
    pub fn new(output_dir_path: &str, runtime_library_path: &str) -> LibrarySupport {
        unsafe {
            let output_dir_path_buffer = output_dir_path.as_bytes();
            let runtime_library_path_buffer = runtime_library_path.as_bytes();
            LibrarySupport {
                support: librarySupportCreateDefault(
                    MlirStringRef {
                        data: output_dir_path_buffer.as_ptr() as *const std::os::raw::c_char,
                        length: output_dir_path_buffer.len() as size_t,
                    },
                    MlirStringRef {
                        data: runtime_library_path_buffer.as_ptr() as *const std::os::raw::c_char,
                        length: runtime_library_path_buffer.len() as size_t,
                    },
                ),
            }
        }
    }

    /// Compile an MLIR into a library.
    pub fn compile(
        &self,
        mlir_code: &str,
        options: Option<CompilationOptions>,
    ) -> Result<LibraryCompilationResult, CompilationError> {
        unsafe {
            let options = options.unwrap_or_else(|| compilationOptionsCreateDefault());
            let mlir_code_buffer = mlir_code.as_bytes();
            let result = librarySupportCompile(
                self.support,
                MlirStringRef {
                    data: mlir_code_buffer.as_ptr() as *const std::os::raw::c_char,
                    length: mlir_code_buffer.len() as size_t,
                },
                options,
            );
            if libraryCompilationResultIsNull(result) {
                return Err(CompilationError("library compilation failed".to_string()));
            }
            Ok(result)
        }
    }

    /// Load server lambda from a compilation result.
    ///
    /// This can be used for executing the compiled function.
    pub fn load_server_lambda(
        &self,
        result: LibraryCompilationResult,
    ) -> Result<ServerLambda, ServerLambdaLoadError> {
        unsafe {
            let server = librarySupportLoadServerLambda(self.support, result);
            if serverLambdaIsNull(server) {
                return Err(ServerLambdaLoadError(
                    "loading server lambda failed".to_string(),
                ));
            }
            Ok(server)
        }
    }
}

#[cfg(test)]
mod test {
    use std::env;
    use tempdir::TempDir;

    use super::*;

    #[test]
    fn test_compiler_round_trip() {
        let module_to_compile = "
                func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
        let result_str = round_trip(module_to_compile).unwrap();
        let expected_module = "module {
  func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
    return %0 : !FHE.eint<5>
  }
}
";
        assert_eq!(expected_module, result_str);
    }

    #[test]
    fn test_compiler_round_trip_invalid_mlir() {
        let module_to_compile = "bla bla bla";
        let result_str = round_trip(module_to_compile);
        assert!(matches!(result_str, Err(CompilationError(_))));
    }

    #[test]
    fn test_compiler_compile_lib() {
        unsafe {
            let module_to_compile = "
            func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
            let runtime_library_path = match env::var("CONCRETE_COMPILER_BUILD_DIR") {
                Ok(val) => val + "/lib/libConcretelangRuntime.so",
                Err(_e) => "".to_string(),
            };
            let temp_dir = TempDir::new("rust_test_compiler_compile_lib").unwrap();
            let support = LibrarySupport::new(
                temp_dir.path().to_str().unwrap(),
                runtime_library_path.as_str(),
            );
            let lib = support.compile(module_to_compile, None).unwrap();
            assert!(!libraryCompilationResultIsNull(lib));
            libraryCompilationResultDestroy(lib);
            // the sharedlib should be enough as a sign that the compilation worked
            assert!(temp_dir.path().join("sharedlib.so").exists());
        }
    }

    /// We want to make sure setting a pointer to null in rust passes the nullptr check in C/Cpp
    #[test]
    fn test_compiler_null_ptr_compatibility() {
        unsafe {
            let lib = Library {
                ptr: std::ptr::null_mut(),
            };
            assert!(libraryIsNull(lib));
        }
    }

    #[test]
    fn test_compiler_load_server_lambda() {
        unsafe {
            let module_to_compile = "
            func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
            let runtime_library_path = match env::var("CONCRETE_COMPILER_BUILD_DIR") {
                Ok(val) => val + "/lib/libConcretelangRuntime.so",
                Err(_e) => "".to_string(),
            };
            let temp_dir = TempDir::new("rust_test_compiler_load_server_lambda").unwrap();
            let support = LibrarySupport::new(
                temp_dir.path().to_str().unwrap(),
                runtime_library_path.as_str(),
            );
            let result = support.compile(module_to_compile, None).unwrap();
            let server = support.load_server_lambda(result).unwrap();
            assert!(!serverLambdaIsNull(server));
            libraryCompilationResultDestroy(result);
            serverLambdaDestroy(server);
        }
    }
}
