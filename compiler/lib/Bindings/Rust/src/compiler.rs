//! Compiler module

use std::path::Path;

use crate::mlir::ffi::*;

#[derive(Debug)]
pub struct CompilerError(String);

/// Parse the MLIR code and returns it.
///
/// The function parse the provided MLIR textual representation and returns it. It would fail with
/// an error message to stderr reporting what's bad with the parsed IR.
///
/// # Examples
/// ```
/// use concrete_compiler_rust::compiler::*;
///
/// let module_to_compile = "
///     func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
///         %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
///         return %0 : !FHE.eint<5>
///     }";
/// let result_str = round_trip(module_to_compile);
/// ```
///
pub fn round_trip(mlir_code: &str) -> Result<String, CompilerError> {
    unsafe {
        let engine = compilerEngineCreate();
        let mlir_code_buffer = mlir_code.as_bytes();
        let compilation_result = compilerEngineCompile(
            engine,
            MlirStringRef {
                data: mlir_code_buffer.as_ptr() as *const std::os::raw::c_char,
                length: mlir_code_buffer.len() as size_t,
            },
            CompilationTarget_ROUND_TRIP,
        );
        if compilationResultIsNull(compilation_result) {
            return Err(CompilerError("roundtrip error".to_string()));
        }
        let module_compiled = compilationResultGetModuleString(compilation_result);
        let result_str = String::from_utf8_lossy(std::slice::from_raw_parts(
            module_compiled.data as *const u8,
            module_compiled.length as usize,
        ))
        .to_string();
        compilationResultDestroyModuleString(module_compiled);
        compilerEngineDestroy(engine);
        Ok(result_str)
    }
}

/// Support for compiling and executing libraries.
pub struct LibrarySupport {
    support: crate::mlir::ffi::LibrarySupport,
}

impl Drop for LibrarySupport {
    fn drop(&mut self) {
        unsafe {
            librarySupportDestroy(self.support);
        }
    }
}

impl LibrarySupport {
    /// LibrarySupport manages build files generated by the compiler under the `output_dir_path`.
    ///
    /// The compiled library needs to link to the runtime for proper execution.
    pub fn new(
        output_dir_path: &str,
        runtime_library_path: &str,
    ) -> Result<LibrarySupport, CompilerError> {
        unsafe {
            let output_dir_path_buffer = output_dir_path.as_bytes();
            let runtime_library_path_buffer = runtime_library_path.as_bytes();
            let support = librarySupportCreateDefault(
                MlirStringRef {
                    data: output_dir_path_buffer.as_ptr() as *const std::os::raw::c_char,
                    length: output_dir_path_buffer.len() as size_t,
                },
                MlirStringRef {
                    data: runtime_library_path_buffer.as_ptr() as *const std::os::raw::c_char,
                    length: runtime_library_path_buffer.len() as size_t,
                },
            );
            if librarySupportIsNull(support) {
                return Err(CompilerError("failed creating library support".to_string()));
            }
            Ok(LibrarySupport { support })
        }
    }

    /// Compile an MLIR into a library.
    pub fn compile(
        &self,
        mlir_code: &str,
        options: Option<CompilationOptions>,
    ) -> Result<LibraryCompilationResult, CompilerError> {
        unsafe {
            let options = options.unwrap_or_else(|| compilationOptionsCreateDefault());
            let mlir_code_buffer = mlir_code.as_bytes();
            let result = librarySupportCompile(
                self.support,
                MlirStringRef {
                    data: mlir_code_buffer.as_ptr() as *const std::os::raw::c_char,
                    length: mlir_code_buffer.len() as size_t,
                },
                options,
            );
            if libraryCompilationResultIsNull(result) {
                return Err(CompilerError("library compilation failed".to_string()));
            }
            Ok(result)
        }
    }

    /// Load server lambda from a compilation result.
    ///
    /// This can be used for executing the compiled function.
    pub fn load_server_lambda(
        &self,
        result: LibraryCompilationResult,
    ) -> Result<ServerLambda, CompilerError> {
        unsafe {
            let server = librarySupportLoadServerLambda(self.support, result);
            if serverLambdaIsNull(server) {
                return Err(CompilerError("loading server lambda failed".to_string()));
            }
            Ok(server)
        }
    }

    /// Load client parameters from a compilation result.
    ///
    /// This can be used for creating keys for the compiled library.
    pub fn load_client_parameters(
        &self,
        result: LibraryCompilationResult,
    ) -> Result<ClientParameters, CompilerError> {
        unsafe {
            let params = librarySupportLoadClientParameters(self.support, result);
            if clientParametersIsNull(params) {
                return Err(CompilerError(
                    "loading client parameters failed".to_string(),
                ));
            }
            Ok(params)
        }
    }

    /// Run a compiled circuit.
    pub fn server_lambda_call(
        &self,
        server_lambda: ServerLambda,
        args: PublicArguments,
        eval_keys: EvaluationKeys,
    ) -> Result<PublicResult, CompilerError> {
        unsafe {
            let result = librarySupportServerCall(self.support, server_lambda, args, eval_keys);
            if publicResultIsNull(result) {
                return Err(CompilerError("failed calling server lambda".to_string()));
            }
            Ok(result)
        }
    }
}

/// Support for keygen, encryption, and decryption.
///
/// Manages cache for keys if provided during creation.
pub struct ClientSupport {
    client_params: crate::mlir::ffi::ClientParameters,
    key_set_cache: Option<KeySetCache>,
}

impl Drop for ClientSupport {
    fn drop(&mut self) {
        unsafe {
            clientParametersDestroy(self.client_params);
            match self.key_set_cache {
                Some(cache) => keySetCacheDestroy(cache),
                None => (),
            }
        }
    }
}

impl ClientSupport {
    pub fn new(
        client_params: ClientParameters,
        key_set_cache_path: Option<&Path>,
    ) -> Result<ClientSupport, CompilerError> {
        unsafe {
            let key_set_cache = match key_set_cache_path {
                Some(path) => {
                    let cache_path_buffer = path.to_str().unwrap().as_bytes();
                    let cache = keySetCacheCreate(MlirStringRef {
                        data: cache_path_buffer.as_ptr() as *const std::os::raw::c_char,
                        length: cache_path_buffer.len() as size_t,
                    });
                    if keySetCacheIsNull(cache) {
                        return Err(CompilerError(
                            "failed creating keyset cache from path".to_string(),
                        ));
                    }
                    Some(cache)
                }
                None => None,
            };
            Ok(ClientSupport {
                client_params,
                key_set_cache,
            })
        }
    }

    /// Fetch a keyset based on the client parameters, and the different seeds.
    ///
    /// If a cache has already been set, this operation would first try to load an existing key,
    /// and generate a new one if no compatible keyset exists.
    pub fn keyset(
        &self,
        seed_msb: Option<u64>,
        seed_lsb: Option<u64>,
    ) -> Result<KeySet, CompilerError> {
        unsafe {
            let key_set = match self.key_set_cache {
                Some(cache) => keySetCacheLoadOrGenerateKeySet(
                    cache,
                    self.client_params,
                    seed_msb.unwrap_or(0),
                    seed_lsb.unwrap_or(0),
                ),
                None => keySetGenerate(
                    self.client_params,
                    seed_msb.unwrap_or(0),
                    seed_lsb.unwrap_or(0),
                ),
            };
            if keySetIsNull(key_set) {
                return Err(CompilerError("getting keyset failed".to_string()));
            }
            Ok(key_set)
        }
    }

    /// Encrypt arguments of a compiled circuit.
    pub fn encrypt_args(
        &self,
        args: &[LambdaArgument],
        key_set: KeySet,
    ) -> Result<PublicArguments, CompilerError> {
        unsafe {
            let public_args = lambdaArgumentEncrypt(
                args.as_ptr(),
                args.len() as u64,
                self.client_params,
                key_set,
            );
            if publicArgumentsIsNull(public_args) {
                return Err(CompilerError("encryption failed".to_string()));
            }
            Ok(public_args)
        }
    }

    pub fn decrypt_result(
        &self,
        result: PublicResult,
        key_set: KeySet,
    ) -> Result<LambdaArgument, CompilerError> {
        unsafe {
            let arg = publicResultDecrypt(result, key_set);
            if lambdaArgumentIsNull(arg) {
                return Err(CompilerError("decryption failed".to_string()));
            }
            Ok(arg)
        }
    }
}

#[cfg(test)]
mod test {
    use std::env;
    use tempdir::TempDir;

    use super::*;

    #[test]
    fn test_compiler_round_trip() {
        let module_to_compile = "
                func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
        let result_str = round_trip(module_to_compile).unwrap();
        let expected_module = "module {
  func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
    return %0 : !FHE.eint<5>
  }
}
";
        assert_eq!(expected_module, result_str);
    }

    #[test]
    fn test_compiler_round_trip_invalid_mlir() {
        let module_to_compile = "bla bla bla";
        let result_str = round_trip(module_to_compile);
        assert!(matches!(result_str, Err(CompilerError(_))));
    }

    #[test]
    fn test_compiler_compile_lib() {
        unsafe {
            let module_to_compile = "
            func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
            let runtime_library_path = match env::var("CONCRETE_COMPILER_BUILD_DIR") {
                Ok(val) => val + "/lib/libConcretelangRuntime.so",
                Err(_e) => "".to_string(),
            };
            let temp_dir = TempDir::new("rust_test_compiler_compile_lib").unwrap();
            let support = LibrarySupport::new(
                temp_dir.path().to_str().unwrap(),
                runtime_library_path.as_str(),
            )
            .unwrap();
            let lib = support.compile(module_to_compile, None).unwrap();
            assert!(!libraryCompilationResultIsNull(lib));
            libraryCompilationResultDestroy(lib);
            // the sharedlib should be enough as a sign that the compilation worked
            assert!(temp_dir.path().join("sharedlib.so").exists());
        }
    }

    /// We want to make sure setting a pointer to null in rust passes the nullptr check in C/Cpp
    #[test]
    fn test_compiler_null_ptr_compatibility() {
        unsafe {
            let lib = Library {
                ptr: std::ptr::null_mut(),
            };
            assert!(libraryIsNull(lib));
        }
    }

    #[test]
    fn test_compiler_load_server_lambda_and_client_parameters() {
        unsafe {
            let module_to_compile = "
            func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
            let runtime_library_path = match env::var("CONCRETE_COMPILER_BUILD_DIR") {
                Ok(val) => val + "/lib/libConcretelangRuntime.so",
                Err(_e) => "".to_string(),
            };
            let temp_dir = TempDir::new("rust_test_compiler_load_server_lambda").unwrap();
            let support = LibrarySupport::new(
                temp_dir.path().to_str().unwrap(),
                runtime_library_path.as_str(),
            )
            .unwrap();
            let result = support.compile(module_to_compile, None).unwrap();
            let server = support.load_server_lambda(result).unwrap();
            assert!(!serverLambdaIsNull(server));
            serverLambdaDestroy(server);
            let client_params = support.load_client_parameters(result).unwrap();
            assert!(!clientParametersIsNull(client_params));
            libraryCompilationResultDestroy(result);
        }
    }

    #[test]
    fn test_compiler_compile_and_exec_scalar_args() {
        unsafe {
            let module_to_compile = "
            func.func @main(%arg0: !FHE.eint<5>, %arg1: !FHE.eint<5>) -> !FHE.eint<5> {
                    %0 = \"FHE.add_eint\"(%arg0, %arg1) : (!FHE.eint<5>, !FHE.eint<5>) -> !FHE.eint<5>
                    return %0 : !FHE.eint<5>
                }";
            let runtime_library_path = match env::var("CONCRETE_COMPILER_BUILD_DIR") {
                Ok(val) => val + "/lib/libConcretelangRuntime.so",
                Err(_e) => "".to_string(),
            };
            let temp_dir = TempDir::new("rust_test_compiler_compile_and_exec_scalar_args").unwrap();
            let lib_support = LibrarySupport::new(
                temp_dir.path().to_str().unwrap(),
                runtime_library_path.as_str(),
            )
            .unwrap();
            // compile
            let result = lib_support.compile(module_to_compile, None).unwrap();
            // loading materials from compilation
            // - server_lambda: used for execution
            // - client_parameters: used for keygen, encryption, and evaluation keys
            let server_lambda = lib_support.load_server_lambda(result).unwrap();
            let client_params = lib_support.load_client_parameters(result).unwrap();
            let client_support = ClientSupport::new(client_params, None).unwrap();
            let key_set = client_support.keyset(None, None).unwrap();
            let eval_keys = keySetGetEvaluationKeys(key_set);
            // build lambda arguments from scalar and encrypt them
            let args = [lambdaArgumentFromScalar(4), lambdaArgumentFromScalar(2)];
            let encrypted_args = client_support.encrypt_args(&args, key_set).unwrap();
            // free args
            args.map(|arg| lambdaArgumentDestroy(arg));
            // execute the compiled function on the encrypted arguments
            let encrypted_result = lib_support
                .server_lambda_call(server_lambda, encrypted_args, eval_keys)
                .unwrap();
            // decrypt the result of execution
            let result_arg = client_support
                .decrypt_result(encrypted_result, key_set)
                .unwrap();
            // get the scalar value from the result lambda argument
            let result = lambdaArgumentGetScalar(result_arg);
            assert_eq!(result, 6);
        }
    }
}
